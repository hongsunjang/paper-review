# NASPipe

## Intro

> Casual dependnecy: two subnet shared layer has dependency
> BSP (bulk synchronchronous parallel): ?
이전 방법들은
1. Casual dependency를 고려하지 못함 Retarii같은 경우 BSP는 bulk 내에서의 casual dependencies를 보장하지 못함
2. Not efficiently manage extra large super net context
 subnet만 GPU 메모리에 올리기 위해선 
 prefetching subnet from CPU to GPU가 필요하지만 
  => subnet is generated by the exploration algorithm
  => 다음 subnet이 뭐가 될지 직전까지도 알 수 없다.
 게다가 DNN operator의 switching feature를 efficient하게 활용하는 이전 논문들이 있다(PipeSwitch, VPipe)

Retarii는 subnet task를 GPU에 할당했지만, subnet을 stage로 나누어 subset of layer를 GPU에 할당하는 것

NASPipe의 장점
1. efficiently Resolve casual dependencies and perform synchronization in training
 => Retiarii는 levearge global sync server

 2. subnet memory 덜 쓸 수 있다.

NASPipe의 insight
1. Larger search space -> fewer dependencies

2.  swap in the context of subnets to be executed 가 시간에 큰 차지를 하는 것을 발견 (VPIPE에서 제시한것 같다.)
=> DNN computation time is roughly deterministic

![comparison](images/comparison.png)


